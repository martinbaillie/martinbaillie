<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>supplychain on Martin Baillie</title><link>https://martin.baillie.id/tags/supplychain/</link><description>Recent content in supplychain on Martin Baillie</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Â© Martin Baillie</copyright><lastBuildDate>Thu, 28 Oct 2021 21:59:00 +1100</lastBuildDate><atom:link href="https://martin.baillie.id/tags/supplychain/index.xml" rel="self" type="application/rss+xml"/><item><title>Stream, Mutate and Sign Images with AWS Lambda and ECR</title><link>https://martin.baillie.id/wrote/stream-mutate-and-sign-images-with-aws-lambda-and-ecr/</link><pubDate>Thu, 28 Oct 2021 21:59:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/stream-mutate-and-sign-images-with-aws-lambda-and-ecr/</guid><description>Image promotion In my experience, an organisation working with container images in any form will typically have a runtime supply chain that first takes an image from an &amp;ldquo;untrusted&amp;rdquo; origin (e.g. a public upstream or the organisation&amp;rsquo;s own permissive development registry), then scans its contents for attributes classified non-compliant to the organisation&amp;rsquo;s security posture, before finally promoting it to a &amp;ldquo;trusted&amp;rdquo; registry (oftentimes after having mutated it to have mandatory annotations and/or a verifiable signature).</description></item><item><title>Git Signature Operations via HashiCorp Vault</title><link>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</link><pubDate>Sun, 04 Oct 2020 12:59:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</guid><description>The typical modern software supply chain starts with an input changeset of source commits triggering a whole raft of manual and automated code checks in a CI environment: peer reviews; full testing pyramid; dependency vetting; automated static analysis and so on.
The outputs of this step are invariably deployable artefacts such as binaries, container images, interpreted/byte code archives or IaC that subsequently need to progress their way through a delivery pipeline comprising at least a pre-production/staging environment (again, typically) before landing in production.</description></item></channel></rss>