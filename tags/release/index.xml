<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>release on Martin Baillie</title><link>https://martin.baillie.id/tags/release/</link><description>Recent content in release on Martin Baillie</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Â© Martin Baillie</copyright><lastBuildDate>Sun, 04 Oct 2020 12:59:00 +1100</lastBuildDate><atom:link href="https://martin.baillie.id/tags/release/index.xml" rel="self" type="application/rss+xml"/><item><title>Git Signature Operations via HashiCorp Vault</title><link>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</link><pubDate>Sun, 04 Oct 2020 12:59:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</guid><description>The typical modern software supply chain starts with an input changeset of source commits triggering a whole raft of manual and automated code checks in a CI environment: peer reviews; full testing pyramid; dependency vetting; automated static analysis and so on.
The outputs of this step are invariably deployable artefacts such as binaries, container images, interpreted/byte code archives or IaC that subsequently need to progress their way through a delivery pipeline comprising at least a pre-production/staging environment (again, typically) before landing in production.</description></item><item><title>Envoy WASM Filters in Rust</title><link>https://martin.baillie.id/wrote/envoy-wasm-filters-in-rust/</link><pubDate>Mon, 17 Aug 2020 08:01:00 +1000</pubDate><guid>https://martin.baillie.id/wrote/envoy-wasm-filters-in-rust/</guid><description>WASM I have had a renewed interest in WASM ever since I read the Mozilla WASI announcement and some of its supporting literature. A few things clicked for me after that, most prominently the potential for use beyond the browser. The compile once, run anywhere aspects echo the Linux container revolution of the last decade, but with true sandboxing, faster starts and without the baggage of a Linux userspace.
The poster child of that revolution was of course Docker.</description></item><item><title>Emacs Evil Motion Training</title><link>https://martin.baillie.id/wrote/evil-motion-training-for-emacs/</link><pubDate>Sun, 28 Jun 2020 10:33:00 +1000</pubDate><guid>https://martin.baillie.id/wrote/evil-motion-training-for-emacs/</guid><description>I made the switch to Emacs last year after having been a resolute vim user ever since I dual booted Slackware on my family&amp;rsquo;s first computer as an early teen.
Needless to say the power of the Emacs pseudo lisp machine quickly opened my eyes. I immediately lunged into consolidating practically all my text use cases sans browsing into Emacs: programming, note taking, RSS, mail, git porcelain, GitHub PRs and issues, IRC/Slack.</description></item><item><title>Ephemeral GitHub Tokens via HashiCorp Vault</title><link>https://martin.baillie.id/wrote/ephemeral-github-tokens-via-hashicorp-vault/</link><pubDate>Mon, 06 Jan 2020 08:39:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/ephemeral-github-tokens-via-hashicorp-vault/</guid><description>GitHub I have found that performing automation against GitHub APIs often necessitates the creation of OAuth Tokens (nb. GitHub refers to these as Personal Access Tokens or PATs). These tokens are tied to a user account, have very coarsely-scoped permissions and do not expire.
The more automation-savvy users in an organisation will likely have created many such tokens with powerful permissions which are being neither rotated nor deleted.
The organisation will also commonly have wasted at least one of their GitHub seats on a robot/machine user for CI/CD purposes.</description></item></channel></rss>