<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>security on Martin Baillie</title><link>https://martin.baillie.id/tags/security/</link><description>Recent content in security on Martin Baillie</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>© Martin Baillie</copyright><lastBuildDate>Sun, 04 Oct 2020 12:59:00 +1100</lastBuildDate><atom:link href="https://martin.baillie.id/tags/security/index.xml" rel="self" type="application/rss+xml"/><item><title>Git Signature Operations via HashiCorp Vault</title><link>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</link><pubDate>Sun, 04 Oct 2020 12:59:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</guid><description>The typical modern software supply chain starts with an input changeset of source commits triggering a whole raft of manual and automated code checks in a CI environment: peer reviews; full testing pyramid; dependency vetting; automated static analysis and so on.
The outputs of this step are invariably deployable artefacts such as binaries, container images, interpreted/byte code archives or IaC that subsequently need to progress their way through a delivery pipeline comprising at least a pre-production/staging environment (again, typically) before landing in production.</description></item><item><title>Controlling Client SNI with Hyper</title><link>https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/</link><pubDate>Sun, 27 Sep 2020 19:09:00 +1000</pubDate><guid>https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/</guid><description>I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&amp;rsquo;s TLS configuration struct.
(&amp;amp;http.Client{ Transport: &amp;amp;http.Transport{ TLSClientConfig: &amp;amp;tls.Config{ ServerName: &amp;#34;somewhere.com&amp;#34;, }, }, }).Get(&amp;#34;https://somewhere-else.com&amp;#34;) And is also what you can achieve with the openssl and curl CLIs for example.</description></item><item><title>Tailscale Support for NixOS</title><link>https://martin.baillie.id/wrote/tailscale-support-for-nixos/</link><pubDate>Fri, 20 Mar 2020 18:24:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/tailscale-support-for-nixos/</guid><description>I have been continuing to run with Tailscale instead of hand-cranked WireGuard on various devices, including my daily driver ThinkPad which runs my other favourite OS—NixOS!
However, until now the configuration was not particularly idiomatic due to there being no upstream Tailscale Nix expressions in nixpkgs.
As it transpired, Dan Anderson of Tailscale is also a NixOS user and with his support I was able to shepherd in a quick PR to introduce a Tailscale module.</description></item><item><title>Tailscale Support for OpenBSD</title><link>https://martin.baillie.id/wrote/tailscale-support-for-openbsd/</link><pubDate>Wed, 05 Feb 2020 20:29:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/tailscale-support-for-openbsd/</guid><description>Tailscale A service called Tailscale launched at the beginning of the month and promises to be the &amp;ldquo;easiest, most secure way to use WireGuard and 2FA&amp;rdquo;.
As an early beta tester of WireGuard and someone who has been carefully tracking its progress towards mainline Linux (currently in net-next, scheduled for 5.6!), I am especially excited to see people much smarter than me start to build next generation VPN businesses centred around it.</description></item><item><title>Ephemeral GitHub Tokens via HashiCorp Vault</title><link>https://martin.baillie.id/wrote/ephemeral-github-tokens-via-hashicorp-vault/</link><pubDate>Mon, 06 Jan 2020 08:39:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/ephemeral-github-tokens-via-hashicorp-vault/</guid><description>GitHub I have found that performing automation against GitHub APIs often necessitates the creation of OAuth Tokens (nb. GitHub refers to these as Personal Access Tokens or PATs). These tokens are tied to a user account, have very coarsely-scoped permissions and do not expire.
The more automation-savvy users in an organisation will likely have created many such tokens with powerful permissions which are being neither rotated nor deleted.
The organisation will also commonly have wasted at least one of their GitHub seats on a robot/machine user for CI/CD purposes.</description></item></channel></rss>