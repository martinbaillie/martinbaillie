<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Wrote on Martin Baillie</title><link>https://martin.baillie.id/wrote/</link><description>Recent content in Wrote on Martin Baillie</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>© Martin Baillie</copyright><lastBuildDate>Sun, 21 Mar 2021 21:19:00 +1100</lastBuildDate><atom:link href="https://martin.baillie.id/wrote/index.xml" rel="self" type="application/rss+xml"/><item><title>Gotchas in the Go Network Packages Defaults</title><link>https://martin.baillie.id/wrote/gotchas-in-the-go-network-packages-defaults/</link><pubDate>Sun, 21 Mar 2021 21:19:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/gotchas-in-the-go-network-packages-defaults/</guid><description>Fool Me Once I have been keeping a wee .org file of gotchas in the defaults of Go&amp;rsquo;s various net packages for a while now. I pull it up each time I&amp;rsquo;m building a service with the standard library, just to make sure I don&amp;rsquo;t miss something that I have already hit in the past. Let&amp;rsquo;s call it learning from one&amp;rsquo;s mistakes where the one in question has a shocking memory.</description></item><item><title>Emacs TRAMP over AWS SSM APIs</title><link>https://martin.baillie.id/wrote/emacs-tramp-over-aws-ssm-apis/</link><pubDate>Sun, 07 Feb 2021 15:18:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/emacs-tramp-over-aws-ssm-apis/</guid><description>Cattle not pets The majority of AWS EC2 I need to operate these days are members of Kubernetes clusters. For remote access to them I&amp;rsquo;m more commonly authenticating to the Kube API to spawn a privileged ephemeral debugger pod rather than accessing the host directly. I have little need for host access even for the remaining minority of ancillary EC2 services I&amp;rsquo;m responsible for because all the observability pillars are pulled or pushed somewhere else, and if something is misbehaving or needing replaced I&amp;rsquo;m more likely to shoot it than debug or patch it.</description></item><item><title>Avoiding Libinput Hysteresis on a ThinkPad</title><link>https://martin.baillie.id/wrote/avoiding-libinput-hysteresis-on-a-thinkpad/</link><pubDate>Sun, 20 Dec 2020 16:21:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/avoiding-libinput-hysteresis-on-a-thinkpad/</guid><description>Making a touchpad work on Linux as well as it does on macOS/Windows. It&amp;rsquo;s a problem as old as time itself, or at least as old as the &amp;ldquo;year of Linux on the desktop&amp;rdquo; meme.
The days of calibrating obscure values that I don&amp;rsquo;t fully understand on the old X11 synaptics driver were supposed to be a thing of the past with libinput, and to be fair they have been, for the most part.</description></item><item><title>Git Signature Operations via HashiCorp Vault</title><link>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</link><pubDate>Sun, 04 Oct 2020 12:59:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/</guid><description>The typical modern software supply chain starts with an input changeset of source commits triggering a whole raft of manual and automated code checks in a CI environment: peer reviews; full testing pyramid; dependency vetting; automated static analysis and so on.
The outputs of this step are invariably deployable artefacts such as binaries, container images, interpreted/byte code archives or IaC that subsequently need to progress their way through a delivery pipeline comprising at least a pre-production/staging environment (again, typically) before landing in production.</description></item><item><title>Controlling Client SNI with Hyper</title><link>https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/</link><pubDate>Sun, 27 Sep 2020 19:09:00 +1000</pubDate><guid>https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/</guid><description>I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&amp;rsquo;s TLS configuration struct.
(&amp;amp;http.Client{ Transport: &amp;amp;http.Transport{ TLSClientConfig: &amp;amp;tls.Config{ ServerName: &amp;#34;somewhere.com&amp;#34;, }, }, }).Get(&amp;#34;https://somewhere-else.com&amp;#34;) And is also what you can achieve with the openssl and curl CLIs for example.</description></item><item><title>Envoy WASM Filters in Rust</title><link>https://martin.baillie.id/wrote/envoy-wasm-filters-in-rust/</link><pubDate>Mon, 17 Aug 2020 08:01:00 +1000</pubDate><guid>https://martin.baillie.id/wrote/envoy-wasm-filters-in-rust/</guid><description>WASM I have had a renewed interest in WASM ever since I read the Mozilla WASI announcement and some of its supporting literature. A few things clicked for me after that, most prominently the potential for use beyond the browser. The compile once, run anywhere aspects echo the Linux container revolution of the last decade, but with true sandboxing, faster starts and without the baggage of a Linux userspace.
The poster child of that revolution was of course Docker.</description></item><item><title>Emacs Evil Motion Training</title><link>https://martin.baillie.id/wrote/evil-motion-training-for-emacs/</link><pubDate>Sun, 28 Jun 2020 10:33:00 +1000</pubDate><guid>https://martin.baillie.id/wrote/evil-motion-training-for-emacs/</guid><description>I made the switch to Emacs last year after having been a resolute vim user ever since I dual booted Slackware on my family&amp;rsquo;s first computer as an early teen.
Needless to say the power of the Emacs pseudo lisp machine quickly opened my eyes. I immediately lunged into consolidating practically all my text use cases sans browsing into Emacs: programming, note taking, RSS, mail, git porcelain, GitHub PRs and issues, IRC/Slack.</description></item><item><title>Your Local Deserves CI, too</title><link>https://martin.baillie.id/wrote/your-local-deserves-ci-too/</link><pubDate>Sat, 06 Jun 2020 15:01:00 +1000</pubDate><guid>https://martin.baillie.id/wrote/your-local-deserves-ci-too/</guid><description>Nix Early last year, after teetering on the edge for a while, I finally took the plunge into the world of Nix. It always seemed to be the logical conclusion to my declarative over imperative leanings and it has not disappointed.
I would classify myself as a semi-retired OS bikeshedder these days. I no longer obsess over ricing my prompt nor switch tiling WMs like they&amp;rsquo;re going out of style. Instead, my prompt is a simple exit code coloured semi-colon and I spend the majority of time in either Firefox or Emacs (+vterm).</description></item><item><title>Tailscale Support for NixOS</title><link>https://martin.baillie.id/wrote/tailscale-support-for-nixos/</link><pubDate>Fri, 20 Mar 2020 18:24:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/tailscale-support-for-nixos/</guid><description>I have been continuing to run with Tailscale instead of hand-cranked WireGuard on various devices, including my daily driver ThinkPad which runs my other favourite OS—NixOS!
However, until now the configuration was not particularly idiomatic due to there being no upstream Tailscale Nix expressions in nixpkgs.
As it transpired, Dan Anderson of Tailscale is also a NixOS user and with his support I was able to shepherd in a quick PR to introduce a Tailscale module.</description></item><item><title>Tailscale Support for OpenBSD</title><link>https://martin.baillie.id/wrote/tailscale-support-for-openbsd/</link><pubDate>Wed, 05 Feb 2020 20:29:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/tailscale-support-for-openbsd/</guid><description>Tailscale A service called Tailscale launched at the beginning of the month and promises to be the &amp;ldquo;easiest, most secure way to use WireGuard and 2FA&amp;rdquo;.
As an early beta tester of WireGuard and someone who has been carefully tracking its progress towards mainline Linux (currently in net-next, scheduled for 5.6!), I am especially excited to see people much smarter than me start to build next generation VPN businesses centred around it.</description></item><item><title>Ephemeral GitHub Tokens via HashiCorp Vault</title><link>https://martin.baillie.id/wrote/ephemeral-github-tokens-via-hashicorp-vault/</link><pubDate>Mon, 06 Jan 2020 08:39:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/ephemeral-github-tokens-via-hashicorp-vault/</guid><description>UPDATE: The plugin described in this fieldnote was recently demoed at HashiCorp&amp;rsquo;s Hashitalks 2021.
GitHub I have found that performing automation against GitHub APIs often necessitates the creation of OAuth Tokens (nb. GitHub refers to these as Personal Access Tokens or PATs). These tokens are tied to a user account, have very coarsely-scoped permissions and do not expire.
The more automation-savvy users in an organisation will likely have created many such tokens with powerful permissions which are being neither rotated nor deleted.</description></item><item><title>Fieldnotes</title><link>https://martin.baillie.id/wrote/fieldnotes/</link><pubDate>Fri, 03 Jan 2020 21:45:00 +1100</pubDate><guid>https://martin.baillie.id/wrote/fieldnotes/</guid><description>Well here we are! I had held off from spewing words onto the internet in long-form until now. That I have made it this far with a new site and first post has been the culmination of:
The compound guilt felt as a practiced user of other people&amp;rsquo;s technical writing to my professional advantage. The accidental consumption of multiple &amp;ldquo;why you should write a technical blog&amp;rdquo;-themed posts in quickfire succession from my feeds.</description></item></channel></rss>