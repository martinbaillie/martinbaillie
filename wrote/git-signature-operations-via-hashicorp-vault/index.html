<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script>if(localStorage.theme!="")document.documentElement.setAttribute("data-theme",localStorage.theme)</script><link rel="stylesheet preload prefetch" as=style type=text/css media=screen href=https://martin.baillie.id/main.deba6deb1f652a43c90d9c71b4783791132f4d937c19a8668cc2b3ed526a17b0f10107bd84952d5ddc357eac4f2226d0a862dcb93757e27b891bcba4cd03f1c6.css integrity="sha512-3rpt6x9lKkPJDZxxtHg3kRMvTZN8GahmjMKz7VJqF7DxAQe9hJUtXdw1fqxPIibQqGLcuTdX4nuJG8ukzQPxxg==" crossorigin=anonymous><title>Martin Baillie | Git Signature Operations via HashiCorp Vault</title><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><link rel=canonical href=https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/><meta property="og:title" content="Git Signature Operations via HashiCorp Vault"><meta name=description content="The typical modern software supply chain starts with an input changeset of source commits triggering a whole raft of manual and automated code checks in a CI environment: peer reviews; full testing pyramid; dependency vetting; automated static analysis and so on.
The outputs of this step are invariably deployable artefacts such as binaries, container images, interpreted/byte code archives or IaC that subsequently need to progress their way through a delivery pipeline comprising at least a pre-production/staging environment (again, typically) before landing in production."><meta property="og:image" content="https://martin.baillie.id//img/me.jpg"><meta itemprop=name content="Git Signature Operations via HashiCorp Vault"><meta name=application-name content="Martin Baillie"><meta property="og:site_name" content="Martin Baillie"><meta property="og:title" content="Git Signature Operations via HashiCorp Vault"><meta property="og:description" content="The typical modern software supply chain starts with an input changeset of source commits triggering a whole raft of manual and automated code checks in a CI environment: peer reviews; full testing pyramid; dependency vetting; automated static analysis and so on.
The outputs of this step are invariably deployable artefacts such as binaries, container images, interpreted/byte code archives or IaC that subsequently need to progress their way through a delivery pipeline comprising at least a pre-production/staging environment (again, typically) before landing in production."><meta property="og:type" content="article"><meta property="og:url" content="https://martin.baillie.id/wrote/git-signature-operations-via-hashicorp-vault/"><meta property="article:published_time" content="2020-10-04T12:59:00+11:00"><meta property="article:modified_time" content="2020-10-04T12:59:00+11:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git Signature Operations via HashiCorp Vault"><meta name=twitter:description content="The typical modern software supply chain starts with an input changeset of source commits triggering a whole raft of manual and automated code checks in a CI environment: peer reviews; full testing pyramid; dependency vetting; automated static analysis and so on.
The outputs of this step are invariably deployable artefacts such as binaries, container images, interpreted/byte code archives or IaC that subsequently need to progress their way through a delivery pipeline comprising at least a pre-production/staging environment (again, typically) before landing in production."><meta name=twitter:site content="@martinbaillie"><meta name=twitter:creator content="@martinbaillie"><meta name=twitter:image content="https://martin.baillie.id//img/me.jpg"><link rel=apple-touch-icon sizes=57x57 href=/img/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/img/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/img/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/img/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/img/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/img/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/img/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/img/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/img/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/img/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/img/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon/favicon-16x16.png><link rel=manifest href=/img/favicon/manifest.json><meta name=msapplication-TileImage content="/img/favicon/ms-icon-144x144.png"><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff"><script src=https://martin.baillie.id/main.2886ed11170936a33d9c58c04cac23204ead8d0a4e228982a00ba971f39d3b391b3cdc6dadb283cdc42af9286068e8901d6998bff909b9edb6482bc2629ebb92.js integrity="sha512-KIbtERcJNqM9nFjATKwjIE6tjQpOIomCoAupcfOdOzkbPNxtrbKDzcQq+ShgaOiQHWmYv/kJue22SCvCYp67kg==" crossorigin=anonymous async></script></head><body><div class=content><header><div class=main><a href=https://martin.baillie.id/>Martin Baillie</a></div><nav><a class=soc id=tags href=/tags title=Tags><i data-feather=tag></i></a><a class=soc id=feed href=/index.xml title="RSS Feed"><i data-feather=rss></i></a><a class=soc id=mode style=cursor:pointer onclick=toggleMode(); title="Switch Theme"><i data-feather=moon></i></a></nav></header><main><article><div class=title><h1>Git Signature Operations via HashiCorp Vault</h1></div><div class=meta><div class=posted><i data-feather=edit-3></i>20201004</div><div class=reading><i data-feather=clock></i>~09 mins</div></div><div class=tldr><strong>tl;dr:</strong>
Vaultsign is a helper tool for performing Git signature operations using Vault.</div><section class=body><div class=single><p>The typical modern software supply chain starts with an input changeset of
source commits triggering a whole raft of manual and automated code checks in a
CI environment: peer reviews; full testing pyramid; dependency vetting;
automated static analysis and so on.</p><p>The outputs of this step are invariably deployable artefacts such as binaries,
container images, interpreted/byte code archives or <a href=https://en.wikipedia.org/wiki/Infrastructure%5Fas%5Fcode>IaC</a> that subsequently need
to progress their way through a delivery pipeline comprising at least a
pre-production/staging environment (again, typically) before landing in
production.</p><p>To achieve that last part necessitates putting the production-bound artefacts on
<em>ice</em> (object store, OCI registry, SCM repository tag etc.) whilst instances of
it are validated in the N pre-production environments in the delivery pipeline.
This is fine for most organisations, but an additional code provenance strategy
is sometimes required in regulated and other high security environments.</p><h2 id=code-provenance>Code Provenance</h2><p>My definition of code provenance here is the proof that those artefacts
deployed to production have been through all prior CI and pre-production steps,
and have additionally retained authenticity and integrity whilst in cold storage
between environments. Sort of like a software <em><a href=https://en.wikipedia.org/wiki/Chain%5Fof%5Fcustody>chain of custody</a></em>.</p><p>The tried and tested approach is to manually sign a checksum of the artefacts
and verify at each stage. This is a concise way to check integrity and
authenticity in one shot, but starts to fall down in modern automated contexts
because of the key distribution and identity problem. That is, an organisation&rsquo;s
engineers can still sign individual commits with their own keys, but it is
ultimately the identity of the automated CI environment that is collating and
producing the deployable artefacts.</p><p>So with identified engineers landing commits, the next link in that chain of
custody is the CI system. It needs to prove it was <em>responsible</em> for producing
those deployable artefacts, and the following runtime stages needing to verify
that fact.</p><hr><p>There are many options in this space but generally speaking it involves the CI
system following the same approach as would have been followed by a human:
produce and sign a checksum of the deployable artefacts. This time, however,
there is the added complexity of the CI system needing to securely identify
itself (machine-to-machine) to some signing service, or otherwise storage
service in order to access the asymmetric key material needed for signing.</p><p>Checksumming strategies can further benefit from reproducible (aka.
deterministic) builds which are within reach these days with the right choice of
language and build system. Then there are specifications like <a href=https://github.com/theupdateframework/specification/blob/master/tuf-spec.md#the-update-framework-specification>The Update
Framework (TUF)</a> laying foundations for securely tracking origin authenticity,
with tools like <a href=https://www.vaultproject.io/>Vault</a>, <a href=https://docs.docker.com/notary/getting%5Fstarted/>Notary</a>, <a href=https://www.openpolicyagent.org/>OPA</a>/<a href=https://github.com/open-policy-agent/gatekeeper>Gatekeeper</a>, and cloud services like <a href=https://cloud.google.com/binary-authorization>GCP
Binary Authorization</a>, and <a href=https://docs.aws.amazon.com/signer/latest/api/Welcome.html>AWS Signer</a> all able to help in this regard.</p><h2 id=vault>Vault</h2><p>This post is about using HashiCorp&rsquo;s Vault in the previously outlined context of
code provenance.</p><p>With a Vault deployment there are numerous machine authentication options that a
CI system&rsquo;s agents can leverage to securely identify themselves, including but
not exclusive to: all major cloud IAM; Kubernetes SAs; AppRole; JWT/OIDC; or TLS
certificates.</p><p>Once authenticated, the agents can utilise Vault&rsquo;s &ldquo;encryption as a service&rdquo;
related backends and plugins (<a href=https://www.vaultproject.io/docs/secrets/transit><code>transit</code></a>, <a href=https://github.com/LeSuisse/vault-gpg-plugin><code>gpg</code></a>) to sign checksums or raw data.</p><p>This constitutes as quite a strong code provenance strategy especially given
Vault&rsquo;s additional RBAC and audit features, provided the subsequent steps in the
software supply chain (&mldr; <em>of custody</em>) have the requisite network access to
the non-sensitive verify endpoints (or otherwise cached public key).</p><hr><p>While the process outlined works well for deployable artefacts like binaries,
things get more awkward when some or all of the deployment collateral is say,
interpreted IaC files (Terraform, Pulumi etc.). In my experience, these are
commonly located on and directly deployed from a branch or tag, both of which
are of course <em><strong>mutable</strong></em>.</p><p>A solution here is to tarball all the IaC files and sign/store/verify them like
the other artefacts, or even just sign/store/verify the branch head commit or
tag SHA.</p><p>Another is to make use of a tool I am releasing today called <a href=https://github.com/martinbaillie/vaultsign><code>vaultsign</code></a>!</p><h2 id=vaultsign>Vaultsign</h2><p><code>vaultsign</code> is a small CLI that can be used as a Git helper to sign (and verify)
commits and tags using HashiCorp’s Vault.</p><p>It does so by implementing just enough of the GPG CLI interface and status
protocol to proxy the Git originating sign and verify requests onwards to your
specified Vault endpoint, and works with both the previously mentioned <a href=https://www.vaultproject.io/docs/secrets/transit>transit
backend</a> and <a href=https://github.com/LeSuisse/vault-gpg-plugin>GPG plugins</a> you may already be using for other code provenance
purposes.</p><p>With it, the CI system can sign a commit or, more commonly, a release tag at the
same time and using the same role and key material as the other deployable
artefacts in the release. Then they can then all be verified together during the
subsequent runtime steps in the chain. All the usual signature related Git
porcelain continues to function and you can even have forges like GitHub verify
and show the coveted green tick if you take the Vault GPG plugin option.</p><h3 id=example-usage>Example Usage</h3><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh><span class=c1># Login to vault.</span>
<span class=p>;</span> <span class=nb>export</span> <span class=nv>VAULT_ADDR</span><span class=o>=</span>https://production.vault.acme.corp
<span class=p>;</span> vault login

<span class=c1># Tell git to use vaultsign.</span>
<span class=p>;</span> git config --local gpg.program /path/to/vaultsign

<span class=c1># Sign a commit and tag.</span>
<span class=p>;</span> <span class=nb>export</span> <span class=nv>VAULT_SIGN_PATH</span><span class=o>=</span>transit/sign/test/sha2-256
<span class=p>;</span> git commit -m <span class=s2>&#34;test signed commit&#34;</span> -S
<span class=p>;</span> git tag -m <span class=s2>&#34;test signed tag&#34;</span> -s <span class=nb>test</span>

<span class=c1># Verify the same commit and tag.</span>
<span class=p>;</span> <span class=nb>export</span> <span class=nv>VAULT_VERIFY_PATH</span><span class=o>=</span>transit/verify/test
<span class=p>;</span> git verify-commit HEAD
<span class=p>;</span> git log -1 --show-signature
<span class=p>;</span> git verify-tag <span class=nb>test</span>
</code></pre></div></div></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/vault>vault</a></li><li><a href=/tags/git>git</a></li><li><a href=/tags/security>security</a></li><li><a href=/tags/release>release</a></li></ul></nav></div></article></main><footer><hr><a class=soc href=https://github.com/martinbaillie title=GitHub><i data-feather=github></i></a><a class=soc href=https://linkedin.com/in/martinbaillie title=LinkedIn><i data-feather=linkedin></i></a><a class=soc href=https://twitter.com/martinbaillie title=Twitter><i data-feather=twitter></i></a><a class=soc href=mailto:martin@baillie.id title=Email><i data-feather=mail></i></a><a class="soc gpg" href=https://github.com/martinbaillie.gpg title="GPG Public Key">C2F0 79DE D64B 7361 006A A099 2A56 EA64 591E 15E4</a>
<a class=menu href=/id>$id</a>
<span class="active menu">fieldnotes</span></footer><script src=https://martin.baillie.id/js/footer.min.28ef130186726a0df510071a5be15530d6861d48b3bd20da5f164370ecc400914afdc175b237ca1a21d9a09b59fe738344e299f812348b8f77c8a9f5c30ed91f.js integrity="sha512-KO8TAYZyag31EAcaW+FVMNaGHUizvSDaXxZDcOzEAJFK/cF1sjfKGiHZoJtZ/nODROKZ+BI0i493yKn1ww7ZHw==" crossorigin=anonymous async></script></div></body></html>