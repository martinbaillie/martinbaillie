<!doctype html><html><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<script>localStorage.theme!=""&&document.documentElement.setAttribute("data-theme",localStorage.theme)</script>
<link rel="stylesheet preload prefetch" as=style type=text/css media=screen href=https://martin.baillie.id/main.60aec2f2e6c07375dfe74807e7dc14a15f8cb0e9d5dbca91bc05311d6e58627e1aef795f341332a861be094a5e5fc8c3c249d63994f5b77f661cd03d56645731.css integrity="sha512-YK7C8ubAc3Xf50gH59wUoV+MsOnV28qRvAUxHW5YYn4a73lfNBMyqGG+CUpeX8jDwknWOZT1t39mHNA9VmRXMQ==" crossorigin=anonymous>
<title>Martin Baillie | Controlling Client SNI with Hyper</title>
<meta name=robots content="index, follow">
<meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
<meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
<link rel=canonical href=https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/>
<meta property="og:title" content="Controlling Client SNI with Hyper">
<meta name=description content="I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&rsquo;s TLS configuration struct.
(&http.Client{ Transport: &http.Transport{ TLSClientConfig: &tls.Config{ ServerName: &#34;somewhere.com&#34;, }, }, }).Get(&#34;https://somewhere-else.com&#34;) And is also what you can achieve with the openssl and curl CLIs for example.">
<meta property="og:image" content="https://martin.baillie.id//img/me.jpg">
<meta itemprop=name content="Controlling Client SNI with Hyper">
<meta name=application-name content="Martin Baillie">
<meta property="og:site_name" content="Martin Baillie"><meta property="og:title" content="Controlling Client SNI with Hyper">
<meta property="og:description" content="I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&rsquo;s TLS configuration struct.
(&http.Client{ Transport: &http.Transport{ TLSClientConfig: &tls.Config{ ServerName: &#34;somewhere.com&#34;, }, }, }).Get(&#34;https://somewhere-else.com&#34;) And is also what you can achieve with the openssl and curl CLIs for example.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/"><meta property="article:section" content="wrote">
<meta property="article:published_time" content="2020-09-27T19:09:00+10:00">
<meta property="article:modified_time" content="2020-09-27T19:09:00+10:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Controlling Client SNI with Hyper">
<meta name=twitter:description content="I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&rsquo;s TLS configuration struct.
(&http.Client{ Transport: &http.Transport{ TLSClientConfig: &tls.Config{ ServerName: &#34;somewhere.com&#34;, }, }, }).Get(&#34;https://somewhere-else.com&#34;) And is also what you can achieve with the openssl and curl CLIs for example.">
<meta name=twitter:site content="@martinbaillie">
<meta name=twitter:creator content="@martinbaillie">
<meta name=twitter:image content="https://martin.baillie.id//img/me.jpg">
<link rel=authorization_endpoint href=https://indieauth.com/auth>
<link rel=token_endpoint href=https://tokens.indieauth.com/token>
<link rel=webmention href=https://webmention.io/martin.baillie.id/webmention>
<link rel=pingback href=https://webmention.io/martin.baillie.id/xmlrpc>
<link rel=apple-touch-icon sizes=57x57 href=/img/favicon/apple-icon-57x57.png>
<link rel=apple-touch-icon sizes=60x60 href=/img/favicon/apple-icon-60x60.png>
<link rel=apple-touch-icon sizes=72x72 href=/img/favicon/apple-icon-72x72.png>
<link rel=apple-touch-icon sizes=76x76 href=/img/favicon/apple-icon-76x76.png>
<link rel=apple-touch-icon sizes=114x114 href=/img/favicon/apple-icon-114x114.png>
<link rel=apple-touch-icon sizes=120x120 href=/img/favicon/apple-icon-120x120.png>
<link rel=apple-touch-icon sizes=144x144 href=/img/favicon/apple-icon-144x144.png>
<link rel=apple-touch-icon sizes=152x152 href=/img/favicon/apple-icon-152x152.png>
<link rel=apple-touch-icon sizes=180x180 href=/img/favicon/apple-icon-180x180.png>
<link rel=icon type=image/png sizes=192x192 href=/img/favicon/android-icon-192x192.png>
<link rel=icon type=image/png sizes=32x32 href=/img/favicon/favicon-32x32.png>
<link rel=icon type=image/png sizes=96x96 href=/img/favicon/favicon-96x96.png>
<link rel=icon type=image/png sizes=16x16 href=/img/favicon/favicon-16x16.png>
<link rel=manifest href=/img/favicon/manifest.json>
<meta name=msapplication-TileImage content="/img/favicon/ms-icon-144x144.png">
<meta name=msapplication-TileColor content="#ffffff">
<meta name=theme-color content="#ffffff">
<script src=https://martin.baillie.id/main.3f3d533c804ec193a3bf2f39185925c3d1c35bbfefbcc4349c90cf1c18a2009e41c963eae886ded936140dbda2c8582f58d13a955cfb56af2eae72817fde756c.js integrity="sha512-Pz1TPIBOwZOjvy85GFklw9HDW7/vvMQ0nJDPHBiiAJ5ByWPq6Ibe2TYUDb2iyFgvWNE6lVz7Vq8urnKBf951bA==" crossorigin=anonymous async></script>
</head>
<body>
<div class=content><header>
<div class=main>
<a href=https://martin.baillie.id/>Martin Baillie</a>
</div>
<nav>
<a class=soc id=tags href=/tags title=Tags><i data-feather=tag></i></a>
<a class=soc id=feed href=/index.xml title="RSS Feed"><i data-feather=rss></i></a>
<a class=soc id=mode style=cursor:pointer onclick=toggleMode() title="Switch Theme"><i data-feather=moon></i></a>
</nav>
</header>
<main>
<article>
<div class=title>
<h1>Controlling Client SNI with Hyper</h1>
</div>
<div class=meta>
<div class=posted><i data-feather=edit-3></i>20200927</div>
<div class=reading><i data-feather=clock></i>~05 mins</div>
</div>
<div class=tldr>
<strong>tl;dr:</strong>
There is at least one way to take control of client SNI in Rust.
</div>
<section class=body>
<div class=single>
<p>I recently revisited Rust after a few years hiatus and in one project I found
myself needing to provide a different Server Name Indicator (SNI) when
initiating a TLS connection to a remote host.</p>
<p>In Go this is as simple as setting the <code>ServerName</code> field on the standard
library&rsquo;s TLS configuration struct.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=p>(</span><span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span>
    <span class=nx>Transport</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Transport</span><span class=p>{</span>
        <span class=nx>TLSClientConfig</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Config</span><span class=p>{</span>
            <span class=nx>ServerName</span><span class=p>:</span> <span class=s>&#34;somewhere.com&#34;</span><span class=p>,</span>
        <span class=p>},</span>
    <span class=p>},</span>
<span class=p>}).</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;https://somewhere-else.com&#34;</span><span class=p>)</span>
</code></pre></div><p>And is also what you can achieve with the <code>openssl</code> and <code>curl</code> CLIs for example.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=p>;</span> openssl s_client -connect somewhere-else.com:443 -servername somewhere.com
<span class=p>;</span> curl --resolve somewhere.com:443:&lt;somewhere-else.com IP&gt; https://somewhere.com
</code></pre></div><p>However, to my surprise, getting the equivalent in Rust was quite awkward. My
search for copypasta-able prior art failed to uncover anything usable and so I
thought I would document at least <em>one</em> way of doing it, with <a href=https://github.com/hyperium/hyper>Hyper</a>, in case it
helps a future weary traveler.</p>
<blockquote>
<p>My project actually started out higher up the abstraction stack with <a href=https://github.com/seanmonstar/reqwest>Reqwest</a> but
at this level there&rsquo;s little in the way of control provided over the underlying
TLS settings. This forces dipping into the likes of Hyper.</p>
</blockquote>
<h2 id=but-why>But why?</h2>
<p>In my experience passing a different SNI is a somewhat typical requirement for
proxies doing virtual hosting or gateways doing <a href=https://en.wikipedia.org/wiki/Domain%5Ffronting>domain fronting</a>.</p>
<p>In my particular case, I needed to send an HTTPS request to an <a href=https://docs.aws.amazon.com/whitepapers/latest/aws-vpc-connectivity-options/aws-privatelink.html>AWS PrivateLink</a>
address but present a different SNI such that the application layer load
balancer on the other side of the link knew which certificate to present and how
to route the requests. I should note that I did not have the environmental
permissions to create a private DNS zone to CNAME or Alias the true hostname to
the PrivateLink one.</p>
<h2 id=hyper>Hyper</h2>
<p>You can achieve this feat with Hyper (and by extension Tokio) <strong>but</strong> I found I
needed to switch from the default TLS implementation to the Rust&rsquo;s native
OpenSSL bindings so I could link against <code>SSL_set_tlsext_host_name</code> in the FFI
of the build system&rsquo;s OpenSSL install.</p>
<p>In the <a href=https://docs.rs/crate/openssl/0.10.30>rust-openssl</a> bindings library this corresponds to
<a href=https://docs.rs/openssl/0.10.30/openssl/ssl/struct.SslRef.html#method.set%5Fhostname><code>openssl::ssl:SslRef::set_hostname()</code></a>.</p>
<p>In addition to the bindings, you will also need to switch Hyper to use
<a href=https://docs.rs/hyper-openssl/0.8.1/hyper%5Fopenssl/><code>hyper-openssl</code></a> crate.</p>
<p>In your <code>Cargo.toml</code> this looks something like:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=p>[</span><span class=nx>dependencies</span><span class=p>]</span>
<span class=nx>hyper</span> <span class=p>=</span> <span class=s2>&#34;0.13.8&#34;</span>
<span class=nx>hyper-openssl</span> <span class=p>=</span> <span class=s2>&#34;0.8.0&#34;</span>
<span class=nx>openssl</span> <span class=p>=</span> <span class=s2>&#34;0.10.30&#34;</span>
</code></pre></div><p>Then take control of the connector and set a callback as you construct your
Hyper client:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>conn</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>HttpsConnector</span>::<span class=n>new</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=n>conn</span><span class=p>.</span><span class=n>set_callback</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// Prevent native TLS lib from inferring and verifying a default SNI.
</span><span class=c1></span><span class=w>    </span><span class=n>c</span><span class=p>.</span><span class=n>set_use_server_name_indication</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>c</span><span class=p>.</span><span class=n>set_verify_hostname</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// And set a custom SNI instead.
</span><span class=c1></span><span class=w>    </span><span class=n>c</span><span class=p>.</span><span class=n>set_hostname</span><span class=p>(</span><span class=s>&#34;somewhere.com&#34;</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>});</span><span class=w>
</span><span class=w></span><span class=n>Client</span>::<span class=n>builder</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>build</span>::<span class=o>&lt;</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>Body</span><span class=o>&gt;</span><span class=p>(</span><span class=n>conn</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>request</span><span class=p>(</span><span class=n>Request</span>::<span class=n>get</span><span class=p>(</span><span class=s>&#34;somewhere-else.com&#34;</span><span class=p>).</span><span class=n>body</span><span class=p>(())</span><span class=o>?</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=k>await</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>That&rsquo;s it! If you capture the TLS <code>ClientHello</code> packet you can confirm the SNI
has changed:</p>
<figure><img src=/ox-hugo/client_hello_wireshark.png alt="WireShark TLS ClientHello">
</figure>
<h2 id=cross-platform-builds>Cross-platform builds</h2>
<p>Using native OpenSSL is not without its pitfalls. YMMV with this but with my
attempts at statically linking for each target platform, even when I could get
the right incantations of the <code>OPENSSL_STATIC</code>, <code>OPENSSL_LIB_DIR</code> and
<code>OPENSSL_INCLUDE_DIR</code> variables to produce a true static binary from a <code>ldd</code>
perspective, I still found the bindings reaching for a system-provided OpenSSL
at runtime and subsequently segfaulting on Linux/amd64.</p>
<p>I eventually gave up with glibc and opted to use the musl libc counterparts.
However compiling musl versions of OpenSSL, zlib and friends is itself a rabbit
hole I did not have time for. Fortunately someone did and I can highly recommend
<a href=https://github.com/clux/muslrust><code>clux/muslrust</code></a> container image for getting this task done.</p>
<p>I also had some issues with the binary being unable to find the CA certificates
on the host system. Solving this was easy thanks to the handy <a href=https://docs.rs/openssl-probe/0.1.2/openssl%5Fprobe/><code>openssl-probe</code></a>
crate.</p>
</div>
</section>
<div class=post-tags>
<nav class="nav tags">
<ul class=tags>
<li><a href=/tags/rust>rust</a></li>
<li><a href=/tags/hyper>hyper</a></li>
<li><a href=/tags/security>security</a></li>
</ul>
</nav>
</div>
</article>
</main>
<footer>
<hr><a class=soc rel=me href=https://github.com/martinbaillie title=GitHub><i data-feather=github></i></a><a class=soc rel=me href=https://linkedin.com/in/martinbaillie title=LinkedIn><i data-feather=linkedin></i></a><a class=soc rel=me href=https://twitter.com/martinbaillie title=Twitter><i data-feather=twitter></i></a><a class=soc rel=me href=mailto:martin@baillie.id title=Email><i data-feather=mail></i></a><a class="soc gpg" href=https://github.com/martinbaillie.gpg title="GPG Public Key">C2F0 79DE D64B 7361 006A A099 2A56 EA64 591E 15E4</a>
<a class=menu href=/id>$id</a>
<span class="active menu">fieldnotes</span>
</footer>
<script src=https://martin.baillie.id/js/footer.min.444ed87071ed3ce3927a6b9c2d891214f17da0a66e9956a5efb26a575eee4dd899bffb64b731153407d893252e02d63c32688d9732b74df3f3d43a3c722cf607.js integrity="sha512-RE7YcHHtPOOSemucLYkSFPF9oKZumVal77JqV17uTdiZv/tktzEVNAfYkyUuAtY8MmiNlzK3TfPz1Do8ciz2Bw==" crossorigin=anonymous async></script>
</div>
</body>
</html>