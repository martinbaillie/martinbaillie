<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Martin Baillie | Controlling Client SNI with Hyper</title><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><link rel=canonical href=https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/><meta property="og:title" content="Martin Baillie | Controlling Client SNI with Hyper"><meta name=description content="I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&rsquo;s TLS configuration struct.
(&http.Client{ Transport: &http.Transport{ TLSClientConfig: &tls.Config{ ServerName: &#34;somewhere.com&#34;, }, }, }).Get(&#34;https://somewhere-else.com&#34;) And is also what you can achieve with the openssl and curl CLIs for example."><meta property="og:image" content="https://martin.baillie.id//img/me.jpg"><meta itemprop=name content="Martin Baillie | Controlling Client SNI with Hyper"><meta name=application-name content="Martin Baillie"><meta property="og:site_name" content="Martin Baillie"><meta property="og:title" content="Controlling Client SNI with Hyper"><meta property="og:description" content="I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&rsquo;s TLS configuration struct.
(&http.Client{ Transport: &http.Transport{ TLSClientConfig: &tls.Config{ ServerName: &#34;somewhere.com&#34;, }, }, }).Get(&#34;https://somewhere-else.com&#34;) And is also what you can achieve with the openssl and curl CLIs for example."><meta property="og:type" content="article"><meta property="og:url" content="https://martin.baillie.id/wrote/controlling-client-sni-with-hyper/"><meta property="article:published_time" content="2020-09-27T00:00:00+10:00"><meta property="article:modified_time" content="2020-09-27T00:00:00+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Controlling Client SNI with Hyper"><meta name=twitter:description content="I recently revisited Rust after a few years hiatus and in one project I found myself needing to provide a different Server Name Indicator (SNI) when initiating a TLS connection to a remote host.
In Go this is as simple as setting the ServerName field on the standard library&rsquo;s TLS configuration struct.
(&http.Client{ Transport: &http.Transport{ TLSClientConfig: &tls.Config{ ServerName: &#34;somewhere.com&#34;, }, }, }).Get(&#34;https://somewhere-else.com&#34;) And is also what you can achieve with the openssl and curl CLIs for example."><meta name=twitter:site content="@martinbaillie"><meta name=twitter:creator content="@martinbaillie"><meta name=twitter:image content="https://martin.baillie.id//img/me.jpg"><link rel=apple-touch-icon sizes=57x57 href=/img/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/img/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/img/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/img/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/img/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/img/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/img/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/img/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/img/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/img/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/img/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon/favicon-16x16.png><link rel=manifest href=/img/favicon/manifest.json><meta name=msapplication-TileImage content="/img/favicon/ms-icon-144x144.png"><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff"><script>if(localStorage.theme)document.documentElement.setAttribute("data-theme",localStorage.theme);</script><link rel="stylesheet preload prefetch" as=style type=text/css media=screen href=https://martin.baillie.id/main.1a92a966a2a8f7588c617b795cff11e8b0e38fca99a44048a51198066a1894610096b89c16e109d9f38f37ebe4e9db238df38d7f190459089474dbe9c7d02cb3.css integrity="sha512-GpKpZqKo91iMYXt5XP8R6LDjj8qZpEBIpRGYBmoYlGEAlricFuEJ2fOPN+vk6dsjjfONfxkEWQiUdNvpx9Assw==" crossorigin=anonymous></head><body><div class=content><header><div class=main><a href=https://martin.baillie.id/>Martin Baillie</a></div><nav><a class=soc id=tags href=/tags title=Tags><i data-feather=tag></i></a><a class=soc id=feed href=/index.xml title="RSS Feed"><i data-feather=rss></i></a><a class=soc id=mode href=javascript:toggleMode(); title="Switch Theme"><i data-feather=moon></i></a></nav></header><main><article><div class=title><h1>Controlling Client SNI with Hyper</h1></div><div class=meta><div class=posted><i data-feather=edit-3></i>20200927</div><div class=reading><i data-feather=clock></i>~05 mins</div></div><div class=tldr><strong>tl;dr:</strong>
There is at least one way to take control of client SNI in Rust.</div><section class=body><div class=single><p>I recently revisited Rust after a few years hiatus and in one project I found
myself needing to provide a different Server Name Indicator (SNI) when
initiating a TLS connection to a remote host.</p><p>In Go this is as simple as setting the <code>ServerName</code> field on the standard
library&rsquo;s TLS configuration struct.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=p>(</span><span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span>
    <span class=nx>Transport</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Transport</span><span class=p>{</span>
        <span class=nx>TLSClientConfig</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Config</span><span class=p>{</span>
            <span class=nx>ServerName</span><span class=p>:</span> <span class=s>&#34;somewhere.com&#34;</span><span class=p>,</span>
        <span class=p>},</span>
    <span class=p>},</span>
<span class=p>}).</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;https://somewhere-else.com&#34;</span><span class=p>)</span>
</code></pre></div><p>And is also what you can achieve with the <code>openssl</code> and <code>curl</code> CLIs for example.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell><span class=p>;</span> openssl s_client -connect somewhere-else.com:443 -servername somewhere.com
<span class=p>;</span> curl --resolve somewhere.com:443:&lt;somewhere-else.com IP&gt; https://somewhere.com
</code></pre></div><p>However, to my surprise, getting the equivalent in Rust was quite awkward. My
search for copypasta-able prior art failed to uncover anything usable and so I
thought I would document at least <em>one</em> way of doing it, with <a href=https://github.com/hyperium/hyper>Hyper</a>, in case it
helps a future weary traveler.</p><blockquote><p>My project actually started out higher up the abstraction stack with <a href=https://github.com/seanmonstar/reqwest>Reqwest</a> but
at this level there&rsquo;s little in the way of control provided over the underlying
TLS settings. This forces dipping into the likes of Hyper.</p></blockquote><h2 id=but-why>But why?</h2><p>In my experience passing a different SNI is a somewhat typical requirement for
proxies doing virtual hosting or gateways doing <a href=https://en.wikipedia.org/wiki/Domain%5Ffronting>domain fronting</a>.</p><p>In my particular case, I needed to send an HTTPS request to an <a href=https://docs.aws.amazon.com/whitepapers/latest/aws-vpc-connectivity-options/aws-privatelink.html>AWS PrivateLink</a>
address but present a different SNI such that the application layer load
balancer on the other side of the link knew which certificate to present and how
to route the requests. I should note that I did not have the environmental
permissions to create a private DNS zone to CNAME or Alias the true hostname to
the PrivateLink one.</p><h2 id=hyper>Hyper</h2><p>You can achieve this feat with Hyper (and by extension Tokio) <strong>but</strong> I found I
needed to switch from the default TLS implementation to the Rust&rsquo;s native
OpenSSL bindings so I could link against <code>SSL_set_tlsext_host_name</code> in the FFI
of the build system&rsquo;s OpenSSL install.</p><p>In the <a href=https://docs.rs/crate/openssl/0.10.30>rust-openssl</a> bindings library this corresponds to
<a href=https://docs.rs/openssl/0.10.30/openssl/ssl/struct.SslRef.html#method.set%5Fhostname><code>openssl::ssl:SslRef::set_hostname()</code></a>.</p><p>In addition to the bindings, you will also need to switch Hyper to use
<a href=https://docs.rs/hyper-openssl/0.8.1/hyper%5Fopenssl/><code>hyper-openssl</code></a> crate.</p><p>In your <code>Cargo.toml</code> this looks something like:</p><div class=highlight><pre class=chroma><code class=language-toml data-lang=toml><span class=p>[</span><span class=nx>dependencies</span><span class=p>]</span>
<span class=nx>hyper</span> <span class=p>=</span> <span class=s2>&#34;0.13.8&#34;</span>
<span class=nx>hyper</span><span class=err>-</span><span class=nx>openssl</span> <span class=p>=</span> <span class=s2>&#34;0.8.0&#34;</span>
<span class=nx>openssl</span> <span class=p>=</span> <span class=s2>&#34;0.10.30&#34;</span>
</code></pre></div><p>Then take control of the connector and set a callback as you construct your
Hyper client:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>conn</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>HttpsConnector</span>::<span class=n>new</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=n>conn</span><span class=p>.</span><span class=n>set_callback</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// Prevent native TLS lib from inferring and verifying a default SNI.
</span><span class=c1></span><span class=w>    </span><span class=n>c</span><span class=p>.</span><span class=n>set_use_server_name_indication</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>c</span><span class=p>.</span><span class=n>set_verify_hostname</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// And set a custom SNI instead.
</span><span class=c1></span><span class=w>    </span><span class=n>c</span><span class=p>.</span><span class=n>set_hostname</span><span class=p>(</span><span class=s>&#34;somewhere.com&#34;</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>});</span><span class=w>
</span><span class=w></span><span class=n>Client</span>::<span class=n>builder</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>build</span>::<span class=o>&lt;</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>Body</span><span class=o>&gt;</span><span class=p>(</span><span class=n>conn</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>request</span><span class=p>(</span><span class=n>Request</span>::<span class=n>get</span><span class=p>(</span><span class=s>&#34;somewhere-else.com&#34;</span><span class=p>).</span><span class=n>body</span><span class=p>(())</span><span class=o>?</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=k>await</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>That&rsquo;s it! If you capture the TLS <code>ClientHello</code> packet you can confirm the SNI
has changed:</p><figure><img src=/ox-hugo/client_hello_wireshark.png alt="WireShark TLS ClientHello"></figure><h2 id=cross-platform-builds>Cross-platform builds</h2><p>Using native OpenSSL is not without its pitfalls. YMMV with this but with my
attempts at statically linking for each target platform, even when I could get
the right incantations of the <code>OPENSSL_STATIC</code>, <code>OPENSSL_LIB_DIR</code> and
<code>OPENSSL_INCLUDE_DIR</code> variables to produce a true static binary from a <code>ldd</code>
perspective, I still found the bindings reaching for a system-provided OpenSSL
at runtime and subsequently segfaulting on Linux/amd64.</p><p>I eventually gave up with glibc and opted to use the musl libc counterparts.
However compiling musl versions of OpenSSL, zlib and friends is itself a rabbit
hole I did not have time for. Fortunately someone did and I can highly recommend
<a href=https://github.com/clux/muslrust><code>clux/muslrust</code></a> container image for getting this task done.</p><p>I also had some issues with the binary being unable to find the CA certificates
on the host system. Solving this was easy thanks to the handy <a href=https://docs.rs/openssl-probe/0.1.2/openssl%5Fprobe/><code>openssl-probe</code></a>
crate.</p></div></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/rust>rust</a></li><li><a href=/tags/hyper>hyper</a></li><li><a href=/tags/security>security</a></li></ul></nav></div></article></main><footer><hr><a class=soc href=https://github.com/martinbaillie title=GitHub><i data-feather=github></i></a><a class=soc href=https://linkedin.com/in/martinbaillie title=LinkedIn><i data-feather=linkedin></i></a><a class=soc href=https://twitter.com/martinbaillie title=Twitter><i data-feather=twitter></i></a><a class=soc href=mailto:martin@baillie.id title=Email><i data-feather=mail></i></a><a class=soc href=https://github.com/martinbaillie.gpg title="GPG Public Key">C2F0 79DE D64B 7361 006A A099 2A56 EA64 591E 15E4</a>
<a class=menu href=/id>$id</a>
<span class="active menu">fieldnotes</span></footer><script src=https://martin.baillie.id/main.973958f01e12093fe43ffa42a348051a785d30fce9de263597ea8b8f5dee989dd6a8aa74c4dc28b6e383f6e0e16be0710e3be747596d2765f496fa591784c803.js integrity="sha512-lzlY8B4SCT/kP/pCo0gFGnhdMPzp3iY1l+qLj13umJ3WqKp0xNwotuOD9uDha+BxDjvnR1ltJ2X0lvpZF4TIAw==" crossorigin=anonymous></script><script data-goatcounter=https://martinbaillie.goatcounter.com/count async src=//gc.zgo.at/count.js></script></div></body></html>